import os
import ycm_core
import logging

LOGGER = logging.getLogger( __name__ )

flags = [
'-Wall',
'-Wextra',
'-Werror',
# '-Wc++98-compat',
'-Wno-long-long',
'-Wno-variadic-macros',
'-fexceptions',
'-DNDEBUG',
'-std=c++11',
'-x',
'c++',
]


known_databases = {}
def GetCompilationDatabase( filename ):
    LOGGER.info('GetCompilationDatabase started')
    db_paths = known_databases.keys()
    file_dir = os.path.dirname( os.path.abspath(filename) )

    for db_path in db_paths:
        if db_path in file_dir:
            LOGGER.info('GetCompilationDatabase found known database in {}'.format(db_path))
            return known_databases[db_path]

    # file doesn`t belong to any known database
    db_path = FindDatabaseDirectoryForFile( filename )
    if db_path is not None:
        database = ycm_core.CompilationDatabase(db_path)
        known_databases[db_path] = database
        LOGGER.info('GetCompilationDatabase found NEW database in {}'.format(db_path))
        return database
    else:
        return None

compilation_database_name = 'compile_commands.json'

def FindDatabaseDirectoryForFile( filename ):
    LOGGER.info('FindDatabaseDirectoryForFile started')
    current_dir = os.path.dirname( os.path.abspath(filename) )

    while True:
        comp_db = os.path.abspath( os.path.join(current_dir, compilation_database_name) )

        LOGGER.info('Checking {}'.format(comp_db))
        if os.path.isfile(comp_db):
            LOGGER.info('Found compilation database in {}'.format(current_dir))
            return current_dir

        parent_dir = os.path.abspath(os.path.join(current_dir, os.path.pardir))

        # we reach root directory and didn`t found anything
        if os.path.samefile(current_dir, parent_dir):
            return None

        current_dir = parent_dir

    

SOURCE_EXTENSIONS = [ '.cpp', '.cxx', '.cc', '.c', '.m', '.mm' ]

def DirectoryOfThisScript():
    return os.path.dirname( os.path.abspath( __file__ ) )


def MakeRelativePathsInFlagsAbsolute( flags, working_directory ):
    if not working_directory:
        return list( flags )
    new_flags = []
    make_next_absolute = False
    path_flags = [ '-isystem', '-I', '-iquote', '--sysroot=' ]
    for flag in flags:
        new_flag = flag

        if make_next_absolute:
            make_next_absolute = False
            if not flag.startswith( '/' ):
                new_flag = os.path.join( working_directory, flag )

        for path_flag in path_flags:
            if flag == path_flag:
                make_next_absolute = True
                break

            if flag.startswith( path_flag ):
                path = flag[ len( path_flag ): ]
                new_flag = path_flag + os.path.join( working_directory, path )
                break

        if new_flag:
            new_flags.append( new_flag )
    return new_flags


def IsHeaderFile( filename ):
    extension = os.path.splitext( filename )[ 1 ]
    return extension in [ '.h', '.hxx', '.hpp', '.hh' ]


def GetCompilationInfoForFile( filename ):
    database = GetCompilationDatabase(filename)
    if not database:
        LOGGER.info('GetCompilationInfoForFile: no database found for file {}'.format(filename))
        return None

    # The compilation_commands.json file generated by CMake does not have entries
    # for header files. So we do our best by asking the db for flags for a
    # corresponding source file, if any. If one exists, the flags for that file
    # should be good enough.
    if IsHeaderFile( filename ):
        basename = os.path.splitext( filename )[ 0 ]
        for extension in SOURCE_EXTENSIONS:
            replacement_file = basename + extension
            if os.path.exists( replacement_file ):
                compilation_info = database.GetCompilationInfoForFile(
                    replacement_file )
                if compilation_info.compiler_flags_:
                    return compilation_info
        return None
    return database.GetCompilationInfoForFile( filename )


def FlagsForFile( filename, **kwargs ):
    # Bear in mind that compilation_info.compiler_flags_ does NOT return a
    # python list, but a "list-like" StringVec object
    compilation_info = GetCompilationInfoForFile( filename )
    final_flags = None
    if compilation_info is not None:
        LOGGER.info('FlagsForFile: found compilation info')
        LOGGER.info('FlagsForFile: with flags = {}'.format(list(compilation_info.compiler_flags_)))
        final_flags = MakeRelativePathsInFlagsAbsolute(
            compilation_info.compiler_flags_,
            compilation_info.compiler_working_dir_ )
    else:
        # roll back to default flags
        LOGGER.info('FlagsForFile: NOT found compilation database, using default flags')
        relative_to = DirectoryOfThisScript()
        final_flags = MakeRelativePathsInFlagsAbsolute( flags, relative_to )

    LOGGER.info('Using flags = {}'.format(final_flags))
    return {
        'flags': final_flags,
        'do_cache': True
    }
